<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Content Manager</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="robots" content="noindex" />
  </head>
  <body>
    <!-- Decap CMS UI -->
    <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>
  
        <script>
      (function () {
        // Automatische Slug-ID-Erzeugung für Projekte
        function mirlSlugifyId(input) {
          if (!input) return '';
          return String(input)
            .toLowerCase()
            .trim()
            // Umlaute/Diakritika entfernen
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            // Alles, was kein a–z oder 0–9 ist, durch Bindestrich ersetzen
            .replace(/[^a-z0-9]+/g, '-')
            // Mehrere/führende/abschließende Bindestriche aufräumen
            .replace(/-+/g, '-')
            .replace(/^-+|-+$/g, '');
        }

        // Feste License-Zeile für alle Projekte
        const DEFAULT_LICENSE = {
          key: 'License',
          value: 'MIT • CC BY-NC-SA',
          url: '#license'
        };

        // Mapping für Status-Labels
        const STATUS_LABELS = {
          released: 'Released',
          draft: 'Draft',
          beta: 'Beta',
          wip: 'WIP',
          planned: 'Planned'
        };

        // Standardwerte je Projekttyp
        const DEFAULT_VALUES = {
          datapack: {
            game: 'Minecraft Java',
            type: 'Datapack'
          },
          printing: {
            projectType: '3D print'
          }
        };

        const SIDEBAR_TEMPLATES = {
          datapack: [
            { key: 'Minecraft' },
            { key: 'Requires' }
          ],
          printing: [
            { key: 'Printer' },
            { key: 'Material' }
          ]
        };

        const { fromJS } = (typeof Immutable !== 'undefined' ? Immutable : {});

        function normaliseText(value) {
          if (typeof value === 'string') {
            return value.trim();
          }

          if (value && typeof value === 'object') {
            const filePath = typeof value.path === 'string'
              ? value.path
              : (typeof value.name === 'string' ? value.name : '');

            if (filePath) {
              return filePath.trim();
            }
          }

          return '';
        }

        function formatStatusLabel(value) {
          const key = normaliseText(value).toLowerCase();
          if (!key) return '';
          return STATUS_LABELS[key] || (key.charAt(0).toUpperCase() + key.slice(1));
        }

        function getModalInfoItems(project) {
          if (!project || typeof project.get !== 'function') return [];
          const modalContent = project.get('modalContent');
          const infoItems = modalContent && modalContent.get ? modalContent.get('infoItems') : null;
          if (infoItems && typeof infoItems.toJS === 'function') {
            return infoItems.toJS();
          }
          return Array.isArray(infoItems) ? infoItems : [];
        }

        function ensureSidebarTemplates(project) {
          if (!project || typeof project.get !== 'function') return project;

          const typeRaw = normaliseText(project.get('type'));
          const type = typeRaw === 'printing' ? 'printing' : 'datapack';
          const templates = SIDEBAR_TEMPLATES[type] || [];
          const infoItems = getModalInfoItems(project);
          const existing = new Set();

          infoItems.forEach((item) => {
            const key = normaliseText(item && item.key);
            if (key) existing.add(key.toLowerCase());
          });

          const ensuredItems = infoItems.slice();

          templates.forEach((template) => {
            const key = normaliseText(template && template.key);
            if (!key || existing.has(key.toLowerCase())) return;
            ensuredItems.push({ key, value: '' });
          });

          if (fromJS && project.setIn) {
            return project.setIn(['modalContent', 'infoItems'], fromJS(ensuredItems));
          }

          return project;
        }

        function findInfoValue(items, key) {
          if (!Array.isArray(items)) return '';
          const match = items.find((item) => item && item.key && String(item.key).toLowerCase() === key.toLowerCase());
          return match && match.value ? normaliseText(match.value) : '';
        }

        function deriveSidebarValues(project) {
          const typeRaw = normaliseText(project && project.get ? project.get('type') : project && project.type);
          const type = typeRaw === 'printing' ? 'printing' : 'datapack';
          const infoItems = getModalInfoItems(project);
          const mcVersion = type === 'datapack'
            ? (findInfoValue(infoItems, 'minecraft') || normaliseText(project.get('mcVersion')))
            : '';
          const requires = type === 'datapack'
            ? (findInfoValue(infoItems, 'requires') || normaliseText(project.get('requires')))
            : '';
          const printer = type === 'printing'
            ? (findInfoValue(infoItems, 'printer') || normaliseText(project.get('printer')))
            : '';
          const material = type === 'printing'
            ? (findInfoValue(infoItems, 'material') || normaliseText(project.get('material')))
            : '';

          return { mcVersion, requires, printer, material, infoItems };
        }

        // Zusätzliche (manuell gepflegte) Infozeilen ohne Duplikate dazumischen
        function mergeCustomInfoItems(autoItems, modalContent) {
          if (!modalContent || typeof modalContent.get !== 'function') return autoItems;

          const existing = modalContent.get('infoItems');
          if (!existing || typeof existing.forEach !== 'function') return autoItems;

          const keys = new Set(
            autoItems.map((item) => String(item.key || '').toLowerCase())
          );

          existing.forEach((entry) => {
            const key = normaliseText(entry && entry.get ? entry.get('key') : entry.key);
            const value = normaliseText(entry && entry.get ? entry.get('value') : entry.value);

            if (!key || !value || keys.has(key.toLowerCase())) return;

            const url = normaliseText(entry && entry.get ? entry.get('url') : entry.url);
            const newTab = !!(entry && entry.get ? entry.get('newTab') : entry.newTab);

            autoItems.push({ key, value, url, newTab });
            keys.add(key.toLowerCase());
          });

          return autoItems;
        }

        // Baut die Infozeilen für Sidebar/Modal anhand der Projektfelder
        function buildInfoItems(project) {
          if (!project || typeof project.get !== 'function') return [];

          const typeRaw = normaliseText(project.get('type'));
          const type = typeRaw === 'printing' ? 'printing' : 'datapack';

          const modalContent = project.get('modalContent');
          const sidebarValues = deriveSidebarValues(project);
          const statusLabel = formatStatusLabel(project.get('status'));
          const missingRequired = [];

          if (type === 'datapack') {
            if (!sidebarValues.mcVersion) missingRequired.push('Minecraft-Version (Sidebar)');
            if (!sidebarValues.requires) missingRequired.push('Erfordert (Sidebar)');
          } else {
            if (!sidebarValues.printer) missingRequired.push('3D-Druck – Drucker (Sidebar)');
            if (!sidebarValues.material) missingRequired.push('3D-Druck – Material (Sidebar)');
          }

          if (missingRequired.length) {
            throw new Error(`Bitte fülle die Pflichtangaben in der Sidebar aus: ${missingRequired.join(', ')}`);
          }

          const items = [];

          if (type === 'datapack') {
            items.push({ key: 'Game', value: DEFAULT_VALUES.datapack.game });
            items.push({ key: 'Type', value: DEFAULT_VALUES.datapack.type });
            if (statusLabel) {
              items.push({ key: 'Status', value: statusLabel });
            }
            items.push({ key: 'Minecraft', value: sidebarValues.mcVersion || '—' });
            items.push({ key: 'Requires', value: sidebarValues.requires || '—' });
          } else {
            items.push({ key: 'Project type', value: DEFAULT_VALUES.printing.projectType });
            items.push({ key: 'Printer', value: sidebarValues.printer || '—' });
            items.push({ key: 'Material', value: sidebarValues.material || '—' });
            if (statusLabel) {
              items.push({ key: 'Status', value: statusLabel });
            }
          }

          // License immer anhängen
          items.push({ ...DEFAULT_LICENSE });

          // zusätzliche, manuelle Einträge dazumischen
          return mergeCustomInfoItems(items, modalContent);
        }

        function getVersionField(version, key) {
          if (!version) return '';
          if (typeof version.get === 'function') {
            return normaliseText(version.get(key));
          }
          return normaliseText(version[key]);
        }

        function hasMeaningfulVersions(collection) {
          if (!collection) return false;

          const list = Array.isArray(collection)
            ? collection
            : (typeof collection.toArray === 'function' ? collection.toArray() : []);

          return list.some((version) => {
            const release = getVersionField(version, 'release');
            const downloadFile = getVersionField(version, 'downloadFile');
            const url = getVersionField(version, 'url');
            const notes = getVersionField(version, 'notes');
            return Boolean(release || downloadFile || url || notes);
          });
        }

        // Wendet Slug + Infozeilen auf alle Projekte im JSON an
        function applyProjectDefaults(data) {
          if (!data || !data.get) return data;

          const projects = data.get('projects');
          if (!projects || typeof projects.map !== 'function') return data;

          const updated = projects.map((project) => {
            if (!project || typeof project.get !== 'function') return project;

            const projectWithTemplates = ensureSidebarTemplates(project);
            const titleRaw = projectWithTemplates.get('title');
            const idRaw = projectWithTemplates.get('id');
            const title = titleRaw == null ? '' : String(titleRaw);
            const currentId = idRaw == null ? '' : String(idRaw).trim();
            const downloadFile = normaliseText(projectWithTemplates.get('downloadFile'));
            const modalInfoItems = buildInfoItems(projectWithTemplates);
            const modalVersions = projectWithTemplates.getIn
              ? projectWithTemplates.getIn(['modalContent', 'versions'])
              : null;
            const hasVersions = hasMeaningfulVersions(modalVersions);

            let nextProject = projectWithTemplates;

            // IDs nur setzen, wenn sie leer sind
            if (!currentId && title) {
              const slugified = mirlSlugifyId(title) || 'projekt';
              nextProject = nextProject.set('id', slugified);
            }

            if (modalInfoItems.length) {
              nextProject = nextProject.setIn(['modalContent', 'infoItems'], modalInfoItems);
            }

            if (fromJS && typeof nextProject.setIn === 'function' && downloadFile && !hasVersions) {
              const createdAtRaw = projectWithTemplates.get('createdAt');
              const defaultDate = createdAtRaw ? String(createdAtRaw) : new Date().toISOString();
              const defaultVersion = {
                release: '1.0.0',
                minecraft: '',
                date: defaultDate,
                downloadFile,
                label: '',
                notes: '',
                details: ''
              };
              // Only inject a default version on initial creation so existing versions stay untouched.
              nextProject = nextProject.setIn(['modalContent', 'versions'], fromJS([defaultVersion]));
            }

            return nextProject;
          });

          return data.set('projects', updated);
        }

        // Nur auf die projects.json anwenden
        function applyProjectDefaultsToEntry(entry) {
          if (!entry || typeof entry.get !== 'function') return entry;

          const slug = entry.get('slug');
          if (slug !== 'projects') {
            return entry;
          }

          const data = entry.get('data');
          const updatedData = applyProjectDefaults(data);

          if (!updatedData || updatedData === data) {
            return entry;
          }

          return entry.set('data', updatedData);
        }

        if (window.CMS) {
          CMS.registerEventListener({
            name: 'preSave',
            handler: ({ entry }) => {
              const updatedEntry = applyProjectDefaultsToEntry(entry);
              if (!updatedEntry || updatedEntry === entry) {
                // keine Änderungen – Originaldaten weiterverwenden
                return;
              }
              return updatedEntry.get('data');
            }
          });
        }
      })();
    </script>


  </body>
</html>
